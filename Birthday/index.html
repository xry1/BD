<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- 修改 1: 网页标题 -->
    <title>Happy Birthday 曾小姐</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            opacity: 0; /* 初始隐藏，等开场结束后显示 */
            transition: opacity 2s ease; /* 缓慢显现 */
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            transition: opacity 0.5s ease;
            text-align: center;
            z-index: 2000;
        }

        /* 开场文字层 */
        #intro-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }

        #intro-text {
            color: #fff;
            font-size: 24px; /* 默认字号 */
            font-weight: lighter;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            text-align: center;
            line-height: 1.8;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .hint {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            font-size: 14px;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
            opacity: 0; /* 初始隐藏 */
            transition: opacity 2s ease 1s; /* 延迟显示 */
        }

        /* 移动端字号调整 */
        @media (max-width: 600px) {
            #intro-text {
                font-size: 20px;
                padding: 0 20px;
            }
        }
    </style>
    
    <!-- 引入 Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>
</head>
<body>

    <!-- 加载提示 -->
    <div id="loading">
        正在为曾小姐<br>准备惊喜...
    </div>

    <!-- 开场动画层 -->
    <div id="intro-layer">
        <div id="intro-text"></div>
    </div>

    <div id="canvas-container"></div>
    <!-- 底部祝福语 -->
    <div class="hint" id="footer-hint">祝宝宝生日快乐 ❤</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // 引入后期处理核心库
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import gsap from 'gsap';

        // ==========================================
        // 开场白配置 (在这里修改你的情话)
        // ==========================================
        const introTexts = [
            "这是我陪你过的第一个生日",
            "很庆幸能在这个特别的日子",
            "陪在你身边",
            "我想把漫天的星辰",
            "和这些美好的瞬间",
            "都收藏起来送给你",
            "愿你眼中有光，心中有爱",
            "曾小姐",
            "生日快乐 ❤"
        ];

        // ==========================================
        // CONFIGURATION 配置区域
        // ==========================================
        
        const config = {
            // 每一层的卡片数量分布 (总和正好为 50 张)
            layerCounts: [12, 10, 9, 8, 5, 3, 3], 
            layerHeightStep: 2.2,
            baseRadius: 6.0,
            cardSize: [1.5, 2.0],
            bgColor: 0x020210,
            fogColor: 0x050515,
        };

        // 修复部分：删除了错误的数组定义，保留了自动生成本地路径的逻辑
        /* 自动生成本地图片路径 
           假设图片存放在同级目录下的 imgs 文件夹中，命名为 1.jpg 到 50.jpg
        */
        const imageUrls = [];
        for (let i = 1; i <= 50; i++) {
            imageUrls.push(`./imgs/${i}.jpg`);
        }

        // ==========================================
        // 场景初始化
        // ==========================================

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(config.bgColor);
        scene.fog = new THREE.FogExp2(config.fogColor, 0.02); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 22);

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false }); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.2;
        controls.maxDistance = 40;
        controls.minDistance = 2;
        controls.maxPolarAngle = Math.PI / 1.5;

        // 灯光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); 
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffd700, 1.5, 40); 
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);
        
        // ==========================================
        // 背景星空 (新增)
        // ==========================================
        function createStarField() {
            const starGeo = new THREE.BufferGeometry();
            const starCount = 2000;
            const posArray = new Float32Array(starCount * 3);
            
            for(let i = 0; i < starCount; i++) {
                const r = 50 + Math.random() * 100; 
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                
                posArray[i*3] = x;
                posArray[i*3+1] = y;
                posArray[i*3+2] = z;
            }
            
            starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            const starMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.25,       
                transparent: true,
                opacity: 0.4,     
                fog: false        
            });
            
            const stars = new THREE.Points(starGeo, starMat);
            return stars;
        }
        
        const starField = createStarField();
        scene.add(starField);

        // ==========================================
        // 背景流星系统 (新增)
        // ==========================================
        const meteors = [];
        const meteorGroup = new THREE.Group();
        scene.add(meteorGroup);

        const meteorGeometry = new THREE.CylinderGeometry(0, 0.4, 20, 8);
        meteorGeometry.rotateX(-Math.PI / 2); 

        function spawnMeteor() {
            const material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending 
            });
            
            const mesh = new THREE.Mesh(meteorGeometry, material);
            
            // 修改：360度环绕分布，确保各个角度都能看到
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 60; // 在半径 30-90 的范围内生成
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const y = 40 + Math.random() * 40; // 从高空落下
            
            mesh.position.set(x, y, z);
            
            // 修改：速度和方向，让流星向四面八方滑落，主要向下
            const speed = 1.5 + Math.random() * 1.5;
            // 随机水平方向
            const moveAngle = Math.random() * Math.PI * 2; 
            
            mesh.userData = {
                velocity: new THREE.Vector3(
                    Math.cos(moveAngle) * speed * 0.5, // 水平位移
                    -speed * 2,                        // 垂直快速下落
                    Math.sin(moveAngle) * speed * 0.5  // 水平位移
                ),
                life: 1.0 
            };
            
            const target = mesh.position.clone().add(mesh.userData.velocity);
            mesh.lookAt(target);
            
            meteorGroup.add(mesh);
            meteors.push(mesh);
        }

        function updateMeteors() {
            if (Math.random() < 0.12) { 
                spawnMeteor();
            }
            
            for (let i = meteors.length - 1; i >= 0; i--) {
                const m = meteors[i];
                m.position.add(m.userData.velocity);
                m.userData.life -= 0.01; // 稍微减慢消失速度，让它飞得更远，俯视能看到更多
                m.material.opacity = m.userData.life;
                if (m.userData.life <= 0) {
                    meteorGroup.remove(m);
                    meteors.splice(i, 1);
                }
            }
        }

        // ==========================================
        // 后期处理 (Post-Processing) - 辉光核心
        // ==========================================

        const renderScene = new RenderPass(scene, camera);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 0.4; 
        bloomPass.radius = 0.02;

        const outputPass = new OutputPass();

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
        composer.addPass(outputPass);

        // ==========================================
        // 构建树 (Photos with Frames)
        // ==========================================

        const treeGroup = new THREE.Group();
        scene.add(treeGroup);
        const cardMeshes = []; // 存储所有可点击的对象 (相框和照片)

        const loader = new THREE.TextureLoader();
        const placeholderTexture = createPlaceholderTexture();

        // 核心变量定义
        const totalTreeHeight = config.layerCounts.length * config.layerHeightStep;
        const startY = -totalTreeHeight / 2;

        let globalCardIndex = 0;

        // --- 新增：中心树干 (修正版) ---
        const cakePosition = 6.8; 
        const trunkBottomY = startY - 1.0; 
        const trunkHeight = cakePosition - trunkBottomY;

        const trunkGeo = new THREE.CylinderGeometry(0.08, 0.08, trunkHeight, 16);
        const trunkMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3,      
            depthWrite: false, 
            side: THREE.DoubleSide
        });
        const trunkMesh = new THREE.Mesh(trunkGeo, trunkMat);
        trunkMesh.position.y = trunkBottomY + (trunkHeight / 2);
        treeGroup.add(trunkMesh);
        // ---------------------

        config.layerCounts.forEach((count, layerIndex) => {
            const progress = layerIndex / (config.layerCounts.length - 1);
            const basePathY = startY + (layerIndex * config.layerHeightStep);
            const radius = config.baseRadius * (1 - progress * 0.85); 

            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                
                const jitter = 0.6 * (1 - progress * 0.5); 
                const randomX = (Math.random() - 0.5) * jitter;
                const randomY = (Math.random() - 0.5) * jitter * 1.5; 
                const randomZ = (Math.random() - 0.5) * jitter;

                const x = Math.cos(angle) * radius + randomX;
                const y = basePathY + randomY;
                const z = Math.sin(angle) * radius + randomZ;

                // 创建相框组合 (Group)
                const cardGroup = new THREE.Group();
                cardGroup.position.set(x, y, z);

                // 核心朝向逻辑 (应用在 Group 上)
                cardGroup.lookAt(0, y, 0); // 先看圆心
                cardGroup.rotateY(Math.PI); // 再背对圆心
                cardGroup.rotateX(0);       // 保持垂直
                cardGroup.rotateZ((Math.random() - 0.5) * 0.15); // 随机摆动

                // 缩放逻辑 (应用在 Group 上)
                const scale = 1 - (progress * 0.25);
                cardGroup.scale.set(scale, scale, scale);

                // --- 1. 创建相框 Mesh ---
                const frameWidth = config.cardSize[0] + 0.15; // 比照片稍宽
                const frameHeight = config.cardSize[1] + 0.15;
                const frameGeo = new THREE.BoxGeometry(frameWidth, frameHeight, 0.05);
                const frameMat = new THREE.MeshBasicMaterial({ color: 0xfffff0 }); // 奶白色相框
                const frameMesh = new THREE.Mesh(frameGeo, frameMat);
                frameMesh.position.z = -0.03; // 稍微靠后
                cardGroup.add(frameMesh);

                // --- 2. 创建照片 Mesh ---
                const photoGeo = new THREE.PlaneGeometry(config.cardSize[0], config.cardSize[1]);
                const imgUrl = imageUrls[globalCardIndex % imageUrls.length];
                // 将材质从 MeshLambertMaterial 改为 MeshBasicMaterial，使其不受光照影响，更加明亮
                const photoMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide,
                    map: placeholderTexture
                });

                loader.load(imgUrl, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    photoMat.map = texture;
                    photoMat.needsUpdate = true;
                });

                const photoMesh = new THREE.Mesh(photoGeo, photoMat);
                photoMesh.position.z = 0.03; // 稍微靠前，避免与相框重叠
                cardGroup.add(photoMesh);

                treeGroup.add(cardGroup);
                
                // 将照片和相框都加入 Raycaster 检测列表
                cardMeshes.push(photoMesh);
                cardMeshes.push(frameMesh);
                
                globalCardIndex++;
            }
        });

        // 修改 4: 占位图上绘制名字
        function createPlaceholderTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 340;
            const ctx = canvas.getContext('2d');
            const hue = Math.random() * 360;
            ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
            ctx.fillRect(0, 0, 256, 340);
            
            // 文字
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            ctx.font = 'bold 36px Arial';
            ctx.fillText('曾小姐', 128, 140);
            
            ctx.font = '30px Arial';
            ctx.fillText('生日快乐', 128, 190);
            
            ctx.font = '50px Arial';
            ctx.fillText('❤', 128, 250);
            
            return new THREE.CanvasTexture(canvas);
        }
        
        // ==========================================
        // 装饰 2: 内部超强发光核心 (静态浮动)
        // ==========================================

        const internalGroup = new THREE.Group();
        // 增大粒子尺寸 (再次调大)
        const innerGeometries = [
            new THREE.BoxGeometry(0.6, 0.6, 0.6),
            new THREE.SphereGeometry(0.4, 16, 16),
            new THREE.OctahedronGeometry(0.55)
        ];
        
        const glowMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            transparent: false
        });

        // 增加粒子数量
        for(let i=0; i<120; i++) {
            const geom = innerGeometries[Math.floor(Math.random() * innerGeometries.length)];
            const mesh = new THREE.Mesh(geom, glowMaterial);
            
            // 优化分布：让粒子在高度上呈现金字塔分布 (指数4)
            const hBias = Math.pow(Math.random(), 4); 
            
            // 计算实际高度 h
            // 修改点：乘以 0.85，确保粒子最高只到达树的 85% 高度
            const h = startY + (hBias * totalTreeHeight * 0.85);

            const rMax = config.baseRadius * (1 - hBias) * 0.6; 
            
            const r = Math.random() * rMax;
            const angle = Math.random() * Math.PI * 2;
            
            mesh.position.set(
                Math.cos(angle) * r,
                h,
                Math.sin(angle) * r
            );
            
            mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            
            mesh.userData = {
                rotationSpeed: Math.random() * 0.03 + 0.01,
                floatSpeed: Math.random() * 0.01 + 0.005,
                floatOffset: Math.random() * Math.PI * 2
            };
            
            internalGroup.add(mesh);
        }
        treeGroup.add(internalGroup);

        // ==========================================
        // 装饰 3: 内部轨道粒子 (绕中心旋转)
        // ==========================================
        
        const orbitGroup = new THREE.Group();
        
        for(let i=0; i<50; i++) {
            const geom = innerGeometries[Math.floor(Math.random() * innerGeometries.length)];
            const mesh = new THREE.Mesh(geom, glowMaterial);
            
            // 高度分布 (指数3)
            const hBias = Math.pow(Math.random(), 3); 
            const h = startY + (hBias * totalTreeHeight * 0.8);

            // 半径
            const maxR = config.baseRadius * (1 - hBias) * 0.55; 
            const r = Math.random() * maxR * 0.9 + 0.1;

            // 初始角度
            const angle = Math.random() * Math.PI * 2;
            
            mesh.position.set(
                Math.cos(angle) * r,
                h,
                Math.sin(angle) * r
            );
            
            mesh.scale.setScalar(0.7); 

            mesh.userData = {
                radius: r,
                angle: angle,
                orbitSpeed: (Math.random() - 0.5) * 0.03,
                rotationSpeed: Math.random() * 0.03,
            };
            
            orbitGroup.add(mesh);
        }
        treeGroup.add(orbitGroup);

        // ==========================================
        // 装饰 4: 树顶 3D 小蛋糕
        // ==========================================
        
        const cakeGroup = new THREE.Group();
        const cakeBaseMat = new THREE.MeshBasicMaterial({ color: 0xffb7c5 });
        const cakeCreamMat = new THREE.MeshBasicMaterial({ color: 0xfffff0 });
        const cherryMat = new THREE.MeshBasicMaterial({ color: 0xff3333 });
        const candleMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee });
        const flameMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });

        const baseGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 32);
        const baseMesh = new THREE.Mesh(baseGeo, cakeBaseMat);
        baseMesh.position.y = 0.2;
        cakeGroup.add(baseMesh);

        const topGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 32);
        const topMesh = new THREE.Mesh(topGeo, cakeCreamMat);
        topMesh.position.y = 0.4 + 0.15;
        cakeGroup.add(topMesh);

        for(let i=0; i<8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const r = 0.35;
            const cherry = new THREE.Mesh(new THREE.SphereGeometry(0.06, 16, 16), cherryMat);
            cherry.position.set(Math.cos(angle)*r, 0.7, Math.sin(angle)*r);
            cakeGroup.add(cherry);
        }

        const candle = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.4, 16), candleMat);
        candle.position.y = 0.7 + 0.2;
        cakeGroup.add(candle);

        const flame = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.15, 8), flameMat);
        flame.position.y = 0.9 + 0.2 + 0.05;
        cakeGroup.add(flame);

        // 整体放大蛋糕
        cakeGroup.scale.set(1.5, 1.5, 1.5);

        cakeGroup.position.set(0, 6.8, 0); 
        
        // 修改 5: 在蛋糕上方添加名字发光牌 (Sprite)
        function createTextSprite() {
            const canvas = document.createElement('canvas');
            // 提高分辨率宽度，防止长文字被截断
            canvas.width = 2048; 
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // 辉光文字效果
            ctx.shadowColor = 'rgba(255, 255, 255, 1.0)';
            ctx.shadowBlur = 30; // 增加光晕
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            
            // 字体大小适中，位置居中
            ctx.font = 'bold 220px Arial';
            ctx.fillText("Happy Birthday", 1024, 400);
            
            ctx.font = 'bold 280px Arial';
            ctx.fillStyle = '#ffb7c5'; // 淡粉色
            ctx.fillText("曾小姐", 1024, 750);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            
            // 调小 3D 场景中的显示大小，使其更精致 (之前是 5.5)
            sprite.scale.set(3.5, 1.75, 1);
            return sprite;
        }

        const nameSprite = createTextSprite();
        // 放在蛋糕上方 (相对于 cakeGroup 的坐标)
        // 蛋糕放大了 1.5 倍，这里的相对高度也微调一下
        nameSprite.position.y = 1.8; 
        cakeGroup.add(nameSprite);

        scene.add(cakeGroup);

        // ==========================================
        // 装饰 5: 圣诞颗粒点缀 (红绿点缀)
        // ==========================================

        const xmasParticleCount = 1500;
        const xmasGeometry = new THREE.BufferGeometry();
        const xmasPositions = new Float32Array(xmasParticleCount * 3);
        const xmasColors = new Float32Array(xmasParticleCount * 3);

        const red = new THREE.Color(0xff0000);
        const green = new THREE.Color(0x00ff00);

        for (let i = 0; i < xmasParticleCount; i++) {
            const hBias = Math.random();
            const h = startY + (hBias * totalTreeHeight);
            const maxR = config.baseRadius * (1 - hBias * 0.9);
            const r = (Math.random() * 0.3 + 0.7) * maxR;
            const angle = Math.random() * Math.PI * 2;
            const jitter = 0.3;
            xmasPositions[i * 3] = Math.cos(angle) * r + (Math.random() - 0.5) * jitter;
            xmasPositions[i * 3 + 1] = h + (Math.random() - 0.5) * jitter;
            xmasPositions[i * 3 + 2] = Math.sin(angle) * r + (Math.random() - 0.5) * jitter;

            const color = Math.random() > 0.5 ? red : green;
            xmasColors[i * 3] = color.r;
            xmasColors[i * 3 + 1] = color.g;
            xmasColors[i * 3 + 2] = color.b;
        }

        xmasGeometry.setAttribute('position', new THREE.BufferAttribute(xmasPositions, 3));
        xmasGeometry.setAttribute('color', new THREE.BufferAttribute(xmasColors, 3));

        const xmasMaterial = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true, 
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const xmasParticles = new THREE.Points(xmasGeometry, xmasMaterial);
        treeGroup.add(xmasParticles);

        // ==========================================
        // 装饰 6: 树底发光礼物盒
        // ==========================================
        const giftGroup = new THREE.Group();
        const giftColors = [0xff3333, 0x33ff33, 0x3333ff, 0xffff00, 0xff00ff, 0x00ffff];

        for (let i = 0; i < 20; i++) {
            const color = giftColors[Math.floor(Math.random() * giftColors.length)];
            const boxSize = Math.random() * 0.4 + 0.3; // 随机大小
            const geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            const material = new THREE.MeshBasicMaterial({ color: color }); // 发光材质
            const box = new THREE.Mesh(geometry, material);

            // 白色丝带 (简单的十字交叉)
            const ribbonMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const ribbonWidth = boxSize * 0.2;
            const ribbon1 = new THREE.Mesh(new THREE.BoxGeometry(boxSize * 1.02, boxSize * 1.02, ribbonWidth), ribbonMat);
            const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(ribbonWidth, boxSize * 1.02, boxSize * 1.02), ribbonMat);
            box.add(ribbon1);
            box.add(ribbon2);

            // 分布在树底周围
            const angle = (i / 20) * Math.PI * 2 + (Math.random() * 0.5);
            const radius = config.baseRadius + 1.0 + Math.random() * 2.0;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            // 放置在“地面”上 (startY 约为最底层卡片的中心高度，这里稍微往下放一点)
            box.position.set(x, startY - 1.2 + boxSize/2, z);
            
            // 随机旋转
            box.rotation.y = Math.random() * Math.PI;
            
            giftGroup.add(box);
        }
        scene.add(giftGroup);


        // ==========================================
        // 交互逻辑 (修正版: 支持点击 Group)
        // ==========================================

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let currentFocus = null;
        let isAnimating = false;

        window.addEventListener('pointerdown', onPointerDown);

        function onPointerDown(event) {
            if (isAnimating) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(cardMeshes);

            if (intersects.length > 0) {
                // 因为我们点击的是 Group 内部的 Mesh (相框或照片)
                // 所以真正的“卡片对象”是它的父级 (cardGroup)
                const clickedGroup = intersects[0].object.parent;
                
                if (currentFocus === clickedGroup) {
                    resetView();
                } else {
                    focusOnCard(clickedGroup);
                }
            } else {
                if (currentFocus) resetView();
            }
        }

        function focusOnCard(cardGroup) {
            currentFocus = cardGroup;
            isAnimating = true;
            controls.autoRotate = false;
            controls.enabled = false;

            const targetPos = new THREE.Vector3();
            // 获取 Group 的世界坐标
            cardGroup.getWorldPosition(targetPos);
            
            // --- 修改核心逻辑：计算正对方向 ---
            // 1. 获取卡片当前的正前方方向 (本地坐标系的 +Z 轴)
            const direction = new THREE.Vector3(0, 0, 1);
            direction.applyQuaternion(cardGroup.quaternion);
            direction.normalize();
            
            // 2. 将相机放置在卡片正前方 3.5 单位处
            const distance = 3.5; 
            const cameraEndPos = targetPos.clone().add(direction.multiplyScalar(distance));

            gsap.to(camera.position, {
                x: cameraEndPos.x,
                y: cameraEndPos.y,
                z: cameraEndPos.z,
                duration: 1.5,
                ease: "power3.inOut",
                onUpdate: () => controls.update()
            });

            gsap.to(controls.target, {
                x: targetPos.x,
                y: targetPos.y,
                z: targetPos.z,
                duration: 1.5,
                ease: "power3.inOut",
                onComplete: () => {
                    isAnimating = false;
                    controls.enabled = true;
                }
            });
        }

        function resetView() {
            if (!currentFocus) return;
            currentFocus = null;
            isAnimating = true;

            gsap.to(controls.target, {
                x: 0,
                y: 0,
                z: 0,
                duration: 1.2,
                ease: "power2.out"
            });
            
            const len = camera.position.length();
            const resetLen = 22; 
            const factor = resetLen / len;

            gsap.to(camera.position, {
                x: camera.position.x * factor,
                y: 8, 
                z: camera.position.z * factor,
                duration: 1.2,
                ease: "power2.out",
                onComplete: () => {
                    isAnimating = false;
                    controls.autoRotate = true;
                    controls.enabled = true;
                }
            });
        }

        // ==========================================
        // 开场动画逻辑 (核心修改)
        // ==========================================
        
        function playIntro() {
            const introTextEl = document.getElementById('intro-text');
            const introLayer = document.getElementById('intro-layer');
            const loadingEl = document.getElementById('loading');
            const footerHint = document.getElementById('footer-hint');
            const canvasContainer = document.getElementById('canvas-container');

            // 1. 隐藏加载文字
            gsap.to(loadingEl, { opacity: 0, duration: 0.5 });

            // 2. 逐句显示文字 (使用 async/await 队列)
            const showLine = (text) => {
                return new Promise(resolve => {
                    // 确保开始前是透明的
                    introTextEl.style.opacity = 0;
                    introTextEl.innerHTML = text;
                    
                    // A. 渐入 (1.0秒 - 稍微加快)
                    gsap.to(introTextEl, { 
                        opacity: 1, 
                        duration: 1.0, 
                        ease: "power2.inOut",
                        onComplete: () => {
                            // B. 停留阅读 (1.2秒 - 缩短停留时间)
                            setTimeout(() => {
                                // C. 渐出 (1.0秒 - 稍微加快)
                                gsap.to(introTextEl, { 
                                    opacity: 0, 
                                    duration: 1.0, 
                                    ease: "power2.inOut",
                                    onComplete: resolve 
                                });
                            }, 1200); 
                        }
                    });
                });
            };

            const runSequence = async () => {
                // 循环播放每一句
                for (const text of introTexts) {
                    await showLine(text);
                }
                
                // 3. 所有文字显示完毕，淡出黑幕，显示场景
                gsap.to(introLayer, { 
                    opacity: 0, 
                    duration: 2.0, 
                    ease: "power2.inOut",
                    onComplete: () => {
                        introLayer.style.display = 'none';
                    }
                });
                
                // 显示 Canvas 和 底部文字
                canvasContainer.style.opacity = 1;
                footerHint.style.opacity = 1;
            };

            // 延迟一点点开始，确保加载过渡平滑
            setTimeout(runSequence, 500);
        }

        // 启动开场动画
        setTimeout(playIntro, 1000);


        // ==========================================
        // 动画循环
        // ==========================================

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // 1. 内部发光体活跃动画 (静态浮动)
            internalGroup.children.forEach(mesh => {
                mesh.rotation.x += mesh.userData.rotationSpeed;
                mesh.rotation.y += mesh.userData.rotationSpeed;
                mesh.position.y += Math.sin(time * 3 + mesh.userData.floatOffset) * 0.008;
            });

            // 2. 轨道粒子动画 (公转)
            orbitGroup.children.forEach(mesh => {
                // 更新角度
                mesh.userData.angle += mesh.userData.orbitSpeed;
                
                // 重新计算位置 (极坐标 -> 直角坐标)
                const r = mesh.userData.radius;
                mesh.position.x = Math.cos(mesh.userData.angle) * r;
                mesh.position.z = Math.sin(mesh.userData.angle) * r;
                
                // 自身也在旋转
                mesh.rotation.x += mesh.userData.rotationSpeed;
                mesh.rotation.y += mesh.userData.rotationSpeed;
            });

            // 3. 蛋糕动画
            cakeGroup.rotation.y = time * 0.5; // 蛋糕缓慢自转
            
            // 火焰跳动动画
            // 利用 sin 波让火焰忽大忽小，忽左忽右
            const flameScale = 1 + Math.sin(time * 15) * 0.2; 
            flame.scale.set(flameScale, flameScale, flameScale);
            flame.rotation.z = Math.sin(time * 20) * 0.1; // 微微晃动

            // 4. 圣诞粒子动画 (缓慢旋转)
            xmasParticles.rotation.y += 0.001;
            
            // 5. 星空背景旋转
            starField.rotation.y -= 0.0005;
            
            // 6. 更新流星
            updateMeteors();

            controls.update();
            composer.render();
        }

        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>